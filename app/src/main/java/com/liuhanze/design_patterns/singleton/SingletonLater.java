package com.liuhanze.design_patterns.singleton;

/**
 * volatile 关键字
 * 可以保证操作的可见性(一个线程修改变变量的值后其他线程会立即可见)，有序性(禁止指令重排序)，不能保证原子性
 *
 * 原子性：经典的银行转账问题A账户-1000 B账户+1000 必须保证同时执行不能被打断
 * (可以通过synchronized和Lock来实现。由于synchronized和Lock能够保证任一时刻只有一个线程执行该代码块，
 * 那么自然就不存在原子性问题了，从而保证了原子性。)
 * 可见性：可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。
 * (通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执
 * 行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。)
 * 有序性：即程序执行的顺序按照代码的先后顺序执行。
 *(另外可以通过synchronized和Lock来保证有序性，很显然，synchronized和Lock保证每个时刻是有一个线程执行
 * 同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。)
 *
 * 在Java中，对基本数据类型的变量的读取操作和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。
 * x = 10;         //语句1
 * y = x;         //语句2
 * x++;           //语句3
 * x = x + 1;     //语句4
 * 上面只有语句1是原子性操作
 *
 * 指令重排序，一般来说，处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先
 * 后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。
 *
 * 内存模型概念：计算机在执行程序时，每条指令都是在CPU中执行的，而执行指令过程中，势必涉及到数据的读取和写入。
 * 由于程序运行过程中的临时数据是存放在主存（物理内存）当中的，这时就存在一个问题，由于CPU执行速度很快，而从内存
 * 读取数据和向内存写入数据的过程跟CPU执行指令的速度比起来要慢的多，因此如果任何时候对数据的操作都要通过和内存的
 * 交互来进行，会大大降低指令执行的速度。因此在CPU里面就有了高速缓存。当程序在运行过程中，会将运算需要的数据从主
 * 存复制一份到CPU的高速缓存当中，那么CPU进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，
 * 再将高速缓存中的数据刷新到主存当中。
 *
 * 为了解决缓存不一致性问题，通常来说有以下2种解决方法：
 *
 * 　　1）通过在总线加LOCK#锁的方式
 *
 * 　　2）通过缓存一致性协议
 *
 * 　　这2种方式都是硬件层面上提供的方式。
 *
 * 缓存一致性协议：最出名的就是Intel 的MESI协议，MESI协议保证了每个缓存中使用的共享变量的副本是一致的。
 * 它核心的思想是：当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号
 * 通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，
 * 那么它就会从内存重新读取。
 */

/**
 * 懒汉式
 * 使用时才创建 需要考虑线程安全
 */
public class SingletonLater {

    /**
     * 为什么要加 volatile
     * 对象创建需要三步：
     *
     *    1 memory = allocate() //分配内存
     *    2 ctorInstanc(memory) //初始化对象
     *    3 instance = memory //设置instance指向刚分配的地址
     *
     * 假如因为指令重排导致执行的顺序变为了132，那么假如a线程中执行完13之后,b线程到达
     * 执行判断语句.发现instance指向的是⼀段地址因此直接不进入判断语句而是直接返回了⼀个没有初始化的空的对象。也不可用。
     *
     * 因为volatile关键字可能会屏蔽掉虚拟机中的一些必需的代码优化，所以运行效率并不是很高。
     * java1.4及以前版本 很多jvm对于volatile关键字的实现都存在问题，会导致加锁失败，因此只能用在java5
     * 及以上版本
     */
    private static volatile SingletonLater instance = null;

    private SingletonLater(){
        //私有的构造方法 阻止了外部创建本类对象
    }

    public static SingletonLater getInstance(){

        //先判断实例是否为空，为空才创建
        if(instance == null){

            /**创建实例时 加锁
            *  注意 在此处可能do something 导致加锁延迟，实例被其他线程创建完
            *  所以 下面创建实例的时候还是要判断一下是否为空
            */
            synchronized (SingletonLater.class){

                //创建实例时先判断实例是否为空
                if(instance == null){
                    instance = new SingletonLater();
                }
            }
        }

        return instance;
    }
}
